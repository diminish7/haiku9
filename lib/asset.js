// Generated by CoffeeScript 1.9.1
(function() {
  var Asset, CoffeeScript, async, attempt, basename, binary, collect, curry, extname, glob, jade, join, map, md2html, promise, read, readdir, ref, ref1, ref2, stylus, yaml,
    slice = [].slice;

  ref = require("fairmont"), read = ref.read, readdir = ref.readdir, async = ref.async, collect = ref.collect, map = ref.map, binary = ref.binary, curry = ref.curry;

  ref1 = require("path"), basename = ref1.basename, extname = ref1.extname, join = ref1.join;

  join = curry(binary(join));

  ref2 = require("when"), attempt = ref2.attempt, promise = ref2.promise;

  glob = require("panda-glob");

  md2html = require("marked");

  jade = require("jade");

  stylus = require("stylus");

  yaml = require("js-yaml");

  CoffeeScript = require("coffee-script");

  Asset = (function() {
    Asset.read = async(function*(path) {
      return new Asset(path, (yield read(path)));
    });

    Asset.readFiles = async(function*(files) {
      var file, i, len, results;
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        results.push((yield Asset.read(file)));
      }
      return results;
    });

    Asset.readDir = async(function*(path) {
      var files;
      files = (yield readdir(path));
      return Asset.readFiles(collect(map(join(path), files)));
    });

    Asset.glob = function(path, pattern) {
      var files;
      files = glob(path, pattern);
      return Asset.readFiles(collect(map(join(path), files)));
    };

    Asset.registerFormatter = function(arg, formatter) {
      var base, base1, from, to;
      to = arg.to, from = arg.from;
      if (this.formatters == null) {
        this.formatters = {};
      }
      if ((base = this.formatters)[from] == null) {
        base[from] = {};
      }
      this.formatters[from][to] = formatter;
      if (this.formatsFor == null) {
        this.formatsFor = {};
      }
      if ((base1 = this.formatsFor)[to] == null) {
        base1[to] = [];
      }
      return this.formatsFor[to].push(from);
    };

    Asset.registerExtension = function(arg) {
      var extension, format;
      extension = arg.extension, format = arg.format;
      if (Asset.extensions == null) {
        Asset.extensions = {};
      }
      Asset.extensions[extension] = format;
      if (Asset.extensionFor == null) {
        Asset.extensionFor = {};
      }
      return Asset.extensionFor[format] = extension;
    };

    Asset.extensionsForFormat = function(format) {
      var formats, i, len, ref3, results;
      formats = this.formatsFor[format];
      if (formats != null) {
        ref3 = [format].concat(slice.call(formats));
        results = [];
        for (i = 0, len = ref3.length; i < len; i++) {
          format = ref3[i];
          results.push(this.extensionFor[format]);
        }
        return results;
      } else {
        return [format];
      }
    };

    Asset.patternForFormat = function(format, name) {
      if (name == null) {
        name = "*";
      }
      return name + ".{" + (this.extensionsForFormat(format)) + ",}";
    };

    Asset.globForFormat = function(path, format) {
      return this.glob(path, this.patternForFormat(format));
    };

    Asset.globNameForFormat = async(function*(path, name, format) {
      var assets, k, v;
      assets = (yield Asset.glob(path, Asset.patternForFormat(format, name)));
      for (k in assets) {
        v = assets[k];
        return v;
      }
      throw new Error("Asset: No matching " + format + " asset found for " + (join(path, name)));
    });

    function Asset(path1, content) {
      var divider, error, extension, frontmatter;
      this.path = path1;
      extension = extname(this.path);
      this.key = basename(this.path, extension);
      this.format = Asset.extensions[extension.slice(1)];
      divider = content.indexOf("\n---\n");
      if (divider >= 0) {
        frontmatter = content.slice(0, divider);
        try {
          this.data = yaml.safeLoad(frontmatter);
        } catch (_error) {
          error = _error;
          this.data = {};
        }
        this.content = content.slice(divider + 5);
      } else {
        this.content = content;
      }
    }

    Asset.prototype.render = function(format, context) {
      var formatter, ref3;
      if (context == null) {
        context = this.context;
      }
      formatter = (ref3 = Asset.formatters[this.format]) != null ? ref3[format] : void 0;
      if (formatter == null) {
        formatter = Asset.identityFormatter;
      }
      if (context == null) {
        context = {};
      }
      context.filename = this.path;
      return formatter(this.content, context);
    };

    return Asset;

  })();

  Asset.registerExtension({
    extension: "md",
    format: "markdown"
  });

  Asset.registerExtension({
    extension: "jade",
    format: "jade"
  });

  Asset.registerExtension({
    extension: "styl",
    format: "stylus"
  });

  Asset.registerExtension({
    extension: "coffee",
    format: "coffeescript"
  });

  Asset.registerExtension({
    extension: "js",
    format: "javascript"
  });

  Asset.identityFormatter = function(content) {
    return promise(function(resolve, reject) {
      return resolve(content);
    });
  };

  Asset.registerFormatter({
    to: "html",
    from: "markdown"
  }, function(markdown) {
    return attempt(md2html, markdown);
  });

  Asset.registerFormatter({
    to: "html",
    from: "jade"
  }, function(markup, context) {
    context.cache = false;
    return attempt(jade.renderFile, context.filename, context);
  });

  Asset.registerFormatter({
    to: "css",
    from: "stylus"
  }, function(code) {
    return attempt(stylus.render, code);
  });

  Asset.registerFormatter({
    to: "javascript",
    from: "coffeescript"
  }, function(code) {
    return attempt(CoffeeScript.compile, code);
  });

  module.exports = Asset;

}).call(this);
